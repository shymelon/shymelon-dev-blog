<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://shymelon-dev-blog.vercel.app/</id>
    <title>Shymelon dev blog</title>
    <updated>2020-08-07T18:43:12.213Z</updated>
    <generator>Saber</generator>
    <author>
        <name>Shymelon</name>
        <email>shymelon.dev@gmail.com</email>
        <uri>https://shymelon-dev-blog.vercel.app</uri>
    </author>
    <link rel="alternate" href="https://shymelon-dev-blog.vercel.app"/>
    <link rel="self" href="https://shymelon-dev-blog.vercel.app/atom.xml"/>
    <subtitle>Небольшой бложик с статейками от молодого бойца переднего конца веб разработки.</subtitle>
    <rights>All rights reserved</rights>
    <entry>
        <title type="html"><![CDATA[Мой опыт написания приложений на платформе VK mini apps. Плюсы, минусы, подводные камни.]]></title>
        <id>https://shymelon-dev-blog.vercel.app/posts/vk-mini-apps-experience.html</id>
        <link href="https://shymelon-dev-blog.vercel.app/posts/vk-mini-apps-experience.html"/>
        <updated>2020-08-07T15:01:13.172Z</updated>
        <summary type="html"><![CDATA[Йоу, в этой статье я хочу поделиться опытом разработки под мини приложения вконтакте, с какими проблемами столкнулся и всем этим. Для написания этой статьи меня натолкнуло очень малое количество инфы по платформе, описание её плюсов и минусов. Стоит помнить, что платформа достаточно молодая (основным репозиториям 10-12 месяцев), поэтому это абсолютно нормальная ситуация.
]]></summary>
        <content type="html"><![CDATA[<p>Йоу, в этой статье я хочу поделиться опытом разработки под мини приложения вконтакте, с какими проблемами столкнулся и всем этим. Для написания этой статьи меня натолкнуло очень малое количество инфы по платформе, описание её плюсов и минусов. Стоит помнить, что платформа достаточно молодая (основным репозиториям 10-12 месяцев), поэтому это абсолютно нормальная ситуация.</p> <h2 id="первое-приложение--экосистема-и-первые-грабли-">Первое приложение. Экосистема и первые грабли.</h2> <p>Для начала наверное стоит сказать, что изначально ни я, ни мои коллеги и не слышали о vk mini apps, впервые узнали о нем на открытии тем хакатона &quot;цифровой прорыв&quot;, где одной из тем было создание бизнес приложения под данную платформу, любого. Видимо, таким образом с помощью хакатона, Вконтакте хочет привлечь разработчиков, что в принципе норм. Я уже лет 5 как пользуюсь kate mobile и не особо слежу за нововведениями, для меня Вконтакте это в первую очередь мессенджер с теми, кто всё ещё не в телеграмме, поэтому изначально эту тему ментально откинул в самый конец приоритета, однако глянув другие стало ясно, что как фронтендеру эта задача будет самой интересной. 5 минут гугления привели меня к следующему:</p> <ul><li>Внутри используется react для представления, собственная библиотека компонентов и API для вызова событий vk и нативных штук.</li> <li>Мутная система дев сервера с отладкой через vk.</li> <li>Есть темплейт, можно будет хотя бы запустить и потыкать.</li> <li>Схема работы примерно следующая: в окошко вставляется билд вашего приложения, через него получается доступ к данным и методам вконтакте.</li></ul> <p>Конечно же, на тот момент кроме как с реактом я ни с чем из этого списка не сталкивался. Покопавшись 15 минут, я кое-как смог запустить темплейт и даже что-то поменять в нём, ура! На этом этапе возникла первая проблема: на локалхосте все вызовы vk bridge api не будут работать, единственный хорошо описанный вариант в официальном гайде это действовать через сервис ngrok, который создает https зеркало вашего локалхоста. Его следует открыть и держать запущенным (кстати зеркало активно в бесплатной версии максимум 8 часов) по порту, указанному в вашем приложении, затем в настройках приложения указать этот временный сайт. Это неудобно хотя бы потому, что зеркало постоянно падает, и эту цепочку действий приходится проделывать из разу в раз. Ну, хотя бы хот релоад работает. Также было непонятно, как через одно окно приложения работать двум разрабам. Уж не знаю как надо было делать, но нам пришлось создавать 3 приложения (моё, другого разработчика и деплой версию) под каждую ветку. Гораздо позднее я совершенно случайно обнаружил совершенно другой способ, который позволяет запускать это дело без танцев с бубном, но в офф. гайде новичок впервые сталкивается именно с первым вариантом. Также было несколько проблем с совместимостью версий вспомогательных библиотек vk ui, но скорее всего их уже пофиксили. Если игнорировать мелкие неудобства, описанные выше, то в целом экосистема мне понравилась. компоненты VK UI оказались очень приятными и понятными в использовании, единственной документации хватило, чтобы без проблем решить все задачи с интерфейсами. И это учитывая то, что с реактом я знаком был лишь по касательной.</p> <h2 id="второе-приложение--теперь-с-мостами-">Второе приложение. Теперь с мостами.</h2> <p>После опыта хакатона с платформой мини аппов, мы решили попробовать выпустить что-нибудь коммерческое. Особо не выдумывая, сделали простенький рандомизатор с возможностью публикации результата в истории. Главным подводным камнем стала возможность перекидывания стикеров в историю: дело в том, что стикер может быть только в форматах jpg\png. Держать на клиенте 100 картинок не хотелось, а как генерировать картинки динамически на клиенте мы не придумали.  Ну окей, сделали сервер, на нём всё работает, но истории открываются пустыми. Почему? А вот сиди догадывайся, ведь Bridge API возвращает 200 даже если есть ошибки, вот так вот. А ещё может работать на андроиде и вылетать с рандомной ошибкой на IOS. А может и не вылетать, это как повезёт. Однако с получением информации о пользователе, вызовом нативной рекламы и прочими чуть более простыми вызовами проблем не было.  В общем Bridge API можно оценить на 6 из 10, не хватает лучшей поддержки кроссплатформы и обработки ошибок.</p> <h2 id="заключение">Заключение</h2> <p>Подводя итоги по платформе, можно выделить следующее:</p> <ul><li>Удобная библиотека компонентов для мобильных устройств, но не адаптированная под ПК.</li> <li>Не самый удобный способ отладки приложений.</li> <li>В целом работоспособный Bridge API, но не без недостатков.</li> <li>Практически нулевая конкуренция. В каталоге меньше 200 приложений!</li> <li>Прямой фидбек от платформы. После отправки на модерацию, поддержка даст советы по UX\UI и функционалу.</li> <li>В целом система полна трейдоффов, как и любая другая кроссплатформенная библиотека.</li></ul>]]></content>
        <published>2020-08-04T00:00:00.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[Функциональное программирование в JS для самых маленьких]]></title>
        <id>https://shymelon-dev-blog.vercel.app/posts/functional-programming-for-dummies.html</id>
        <link href="https://shymelon-dev-blog.vercel.app/posts/functional-programming-for-dummies.html"/>
        <updated>2020-08-04T09:01:51.947Z</updated>
        <summary type="html"><![CDATA[Я человек практичный, поэтому когда я впервые увидел функциональный подход я малость приофигел. Какие-то странные функции которые передаются другим функциям как переменные, лямбда выражения, зачем это всё, ведь можно сделать куда проще? Но с течением времени мой код становился сложнее, циклы и условия становились всё вложеннее, а переменные изменялись всё в больших местах, и в один момент я понял - с этим что-то надо делать. Так я попробовал ФП ещё раз и начал искать ему практическое применение в рутинных задачах, делая их проще и понятнее.
]]></summary>
        <content type="html"><![CDATA[<h1 id="вступление">Вступление</h1> <p>Я человек практичный, поэтому когда я впервые увидел функциональный подход я малость приофигел. Какие-то странные функции которые передаются другим функциям как переменные, лямбда выражения, зачем это всё, ведь можно сделать куда проще? Но с течением времени мой код становился сложнее, циклы и условия становились всё вложеннее, а переменные изменялись всё в больших местах, и в один момент я понял - с этим что-то надо делать. Так я попробовал ФП ещё раз и начал искать ему практическое применение в рутинных задачах, делая их проще и понятнее.</p> <p>В этой статье я постараюсь максимально просто рассказать новичкам о том, как начать свои первые шаги в функциональном программировании и показать на реальном примере, как пользоваться ими с минимальными усилиями, без сложных понятий и теории функционального программирования.</p> <h2 id="disclaimer">Disclaimer</h2> <p>Я не претендую на последнюю инстанцию в этом вопросе, ровно, как и то, что это потребуется именно вам и тем более не собираюсь разводить холивар насчёт того какая парадигма лучше. Также стоит помнить, что нижеописанные советы лишь первый шаг, и они могут (и большинство должны!) использоваться и в объектно-ориентированном подходе.</p> <h2 id="never-gonna-let---">Never gonna let...</h2> <p>Для начала следует максимально избавиться в своем коде от переменных, заменив их константами. Зачем? Всё просто: чем чаще вы меняете переменную, тем больше условий и мест изменений надо удержать в голове. Для первых шагов достаточно полностью заменить let и var на const, это подстегнёт вас делать сразу две вещи: правильно называть переменные и писать меньше императивного кода (цикл for(const i = ...)  очевидно работать не будет, придётся искать замену в виде функций высшего порядка)</p> <h2 id="циклы-циклы">Циклы, циклы</h2> <p>Вторая вещь, которой учат в институте после переменных это циклы. Казалось бы, без переменных прожить можно, но без циклов-то как? Проще простого. <a rel="noopener noreferrer" target="_blank" href="https://learn.javascript.ru/array-iteration">Встроенные методы перебора JavaScript</a> покрывают 90% рутинных нужд в циклах. Описывать как ими пользоваться я не буду, это объясняют лучше меня по ссылке выше. Я же постараюсь как можно проще описать самые используемые и привести типичные юзкейсы.</p> <h3 id="map">map</h3> <p>Возвращает новый массив, над каждым элементом  поработала функция f(элемент_массива), которую вы передаёте в качестве первого аргумента. Типичные юзкейсы: получить из массива объектов массив из конкретного поля объектов, трансформировать каждое значение из массива.</p> <h3 id="filter-и-sort">filter и sort</h3> <p>Названия говорят сами за себя: первый метод фильтрует, второй сортирует.</p> <h3 id="reduce">reduce</h3> <p>А вот эта интереснее. На пальцах описать сложно, грубо говоря применяет функцию на каждый элемент массива с сохранением прошлого результата, возвращает его же. Используется когда надо сократить массив до одного значения, например найти сумму всех элементов массива или вернуть строку с перечислением элементов массива. Самый мощный из встроенных методов, но самый сложный для восприятия. Для полного понимания советую вывести какой-нибудь массив с помощью него и посмотреть, какое значение будет в каждом аргументе на каждой итерации, также не стоит забывать про аргумент initialValue.</p> <h3 id="foreach">forEach</h3> <p>Единственный метод из перечисленных, который ничего не возвращает. Классически его используют для замены цикла for, когда без побочных эффектов не обойтись. Например, для каждого из элементов массива отправить запрос на сервер.</p> <h2 id="практика">Практика</h2> <p>Попробуем отрефакторить какой-нибудь реальный пример с минимальным изменением в логике. Для чистоты эксперимента я залез на сайт с компонентами Vue и взял первый попавшийся на глаза репозиторий. Это компонент для Vue, который генерирует программную анимацию текста из случайных букв и цифр. Основной движ компонента происходит в следующих строчках:</p> <div class="saber-highlight" data-lang="javascript"><pre class="saber-highlight-code language-javascript"><code class="language-javascript">this.textRendered = &quot;&quot;;
                //create initial garble string
                for (var i = 0; i &lt; this.text.length; i++) {
                    if (this.text.charAt(i) != &quot; &quot;) {
                        this.textRendered += Math.random().toString(36).substr(2, 1);
                    } else {
                        this.textRendered += &quot; &quot;;
                    }
                }
                this.garbleInterval = setInterval(() =&gt; {
                    //by chance add either real char or another random
                    for (var i = 0; i &lt; this.text.length; i++) {
                        if (this.text.charAt(i) != &quot; &quot; &amp;&amp; this.text.charAt(i) != this
                            .textRendered.charAt(i)) {
                            if (Math.random() &gt; this.chance) {
                                //another random
                                this.textRendered = this.replaceAt(this.textRendered, i, Math
                                    .random().toString(36).substr(2, 1));
                            } else {
                                //the real one
                                this.textRendered = this.replaceAt(this.textRendered, i, this
                                    .text.charAt(i));
                            }
                        }
                    }</code></pre></div><p>Ухх. Для начала попробуем переписать 1 цикл. Всё что он делает, это просто проходит по символам в строке и меняет их на случайное значение. В отдельности выглядит несложно, но требует времени, чтобы понять что тут происходит и внимания, чтобы запомнить все изменяющиеся переменные. Для начала избавимся от цикла, он здесь явно лишний:</p> <div class="saber-highlight" data-lang="js"><pre class="saber-highlight-code language-js"><code class="language-js">this.textRendered = this.text.split('').map(v =&gt; v !== ' ' ? Math.random().toString(36).substr(2, 1)) : &quot; &quot;).join('');</code></pre></div><p>Без цикла выглядит компактнее, но неказистость и сумбурность в коде никуда не ушла, спасибо реализации рандомайзера. Вынесем её в отдельную функцию, тем более дальше по коду она нам ещё пригодится.</p> <div class="saber-highlight" data-lang="js"><pre class="saber-highlight-code language-js"><code class="language-js">const getRandomChar = () =&gt; Math.random().toString(36).substr(2, 1);
this.textRendered = this.text.split('').map(v =&gt; v !== ' ' ? getRandomChar() : &quot; &quot;).join('');</code></pre></div><p>Можно ли назвать этот код чисто функциональным? Абсолютно нет. Можно ли продолжить улучшать его? Разумеется. Но наша цель на данный момент улучшить качество при минимальных усилиях, а как известно 20% усилий приносят 80% результата.</p> <p>Следующий кусок кода более трудоёмкий, в нём нас ожидают классические грехи императивного подхода: циклы с условием, вложеность, дублирование кода. Для начала попробуем понять, что делают отдельные куски кода в условиях и вынести их в правильно именованные функции:</p> <div class="saber-highlight" data-lang="js"><pre class="saber-highlight-code language-js"><code class="language-js">this.text.charAt(i) != &quot; &quot; &amp;&amp; this.text.charAt(i) != this.textRendered.charAt(i)</code></pre></div><p>Проверяет должен ли меняться текущий символ или нет. Так и назовём:</p> <div class="saber-highlight" data-lang="js"><pre class="saber-highlight-code language-js"><code class="language-js">const shouldBeCharReplaced = (i) =&gt; this.text.charAt(i) != &quot; &quot; &amp;&amp; this.text.charAt(i) != this.textRendered.charAt(i);</code></pre></div><p>Хочу заметить, что мы используем внешние переменные в нашей функции, что не есть хорошо, но наша цель на сегодня не написать идеальный функциональный код, а сделать уже существующий код более читаемым с минимальными усилиями. Конечно же, в идеале мы бы хотели полностью переписать логику компонента, но предположим на нас давят сроки, а компонент нужен читаемым прямо сейчас.
Но что-то я отвлёкся. Далее:</p> <div class="saber-highlight" data-lang="js"><pre class="saber-highlight-code language-js"><code class="language-js">if (Math.random() &gt; this.chance) {
                                //another random
                                this.textRendered = this.replaceAt(this.textRendered, i, Math
                                    .random().toString(36).substr(2, 1));
                            } else {
                                //the real one
                                this.textRendered = this.replaceAt(this.textRendered, i, this
                                    .text.charAt(i));
                            }</code></pre></div><p>Меняет символ на текущем индексе на еще один рандом или настоящий в зависимости от коэфициента. Проще простого, к тому же вишенкой на торте мы видим код, который мы уже вынесли в отдельную функцию getRandomChar():</p> <div class="saber-highlight" data-lang="js"><pre class="saber-highlight-code language-js"><code class="language-js">const stringWithReplacedChar = (i) =&gt; {
    if(Math.random() &gt; this.chance) {
        return this.replaceAt(this.textRendered, i, getRandomChar())
        }
        return replaceAt(this.textRendered, i, this.text.charAt(i));
}</code></pre></div><p>Осталось избавиться от цикла и соединить всё вместе. Т.к. в реализации автор внутри цикла каждый раз меняет всю строку, а изначальную реализацию мы решили не трогать из-за якобы горящих сроков, то придётся использовать forEach, который чаще всего используется для обработки побочных эффектов.</p> <div class="saber-highlight" data-lang="js"><pre class="saber-highlight-code language-js"><code class="language-js">// _ используем как плейсхолдер для ненужного нам значения
text.split('').forEach((_,i) =&gt; {
    if(shouldBeCharReplaced(i)) {
        textRendered = stringWithReplacedChar(i);
    }
})</code></pre></div><p>Полный результат рефакторинга:</p> <div class="saber-highlight" data-lang="js"><pre class="saber-highlight-code language-js"><code class="language-js">const getRandomChar = () =&gt; Math.random().toString(36).substr(2, 1);

const shouldBeCharReplaced = (i) =&gt; this.text.charAt(i) != &quot; &quot; &amp;&amp; this.text.charAt(i) != this.textRendered.charAt(i);

//by chance add either real char or another random
const stringWithReplacedChar = (i) =&gt; {
    if(Math.random() &gt; this.chance) {
        //another random
        return this.replaceAt(this.textRendered, i, getRandomChar());
        }
        //the real one
        return replaceAt(this.textRendered, i, this.text.charAt(i));
}

//create initial garble string
this.textRendered = this.text.split('').map(v =&gt; v !== ' ' ? getRandomChar() : &quot; &quot;).join('');

text.split('').forEach((_,i) =&gt; {
    if(shouldBeCharReplaced(i)) {
        this.textRendered = stringWithReplacedChar(i);
    }
})</code></pre></div><p>В итоге теперь, чтобы понять, как работает компонент, нам необходимо посмотреть лишь на последние 6 строк вместо первоначальных циклов и вложенных условий. Конечно, будь у нас больше времени, мы бы могли в разы улучшить и данный пример. Например использовать композицию, сделать переменные максимально неизменяемыми, полностью избавиться от условий и побочных эффектов, но это уже тема для другой статьи (:</p>]]></content>
        <published>2020-07-20T00:00:00.000Z</published>
    </entry>
</feed>