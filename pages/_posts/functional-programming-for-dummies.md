---
title: Функциональное программирование в JS для самых маленьких
date: 2020-07-20
layout: post
---

# Вступление
Я человек практичный, поэтому когда я впервые увидел функциональный подход я малость приофигел. Какие-то странные функции которые передаются другим функциям как переменные, лямбда выражения, зачем это всё, ведь можно сделать куда проще? Но с течением времени мой код становился сложнее, циклы и условия становились всё вложеннее, а переменные изменялись всё в больших местах, и в один момент я понял - с этим что-то надо делать. Так я попробовал ФП ещё раз и начал искать ему практическое применение в рутинных задачах, делая их проще и понятнее.

В этой статье я постараюсь максимально просто рассказать новичкам о том, как начать свои первые шаги в функциональном программировании и показать на реальном примере, как пользоваться ими с минимальными усилиями, без сложных понятий и теории функционального программирования.

## Disclaimer
Я не претендую на последнюю инстанцию в этом вопросе, ровно, как и то, что это потребуется именно вам и тем более не собираюсь разводить холивар насчёт того какая парадигма лучше. Также стоит помнить, что нижеописанные советы лишь первый шаг, и они могут (и большинство должны!) использоваться и в объектно-ориентированном подходе.

## Never gonna let...

Для начала следует максимально избавиться в своем коде от переменных, заменив их константами. Зачем? Всё просто: чем чаще вы меняете переменную, тем больше условий и мест изменений надо удержать в голове. Для первых шагов достаточно полностью заменить let и var на const, это подстегнёт вас делать сразу две вещи: правильно называть переменные и писать меньше императивного кода (цикл for(const i = ...)  очевидно работать не будет, придётся искать замену в виде функций высшего порядка)

## Циклы, циклы
Вторая вещь, которой учат в институте после переменных это циклы. Казалось бы, без переменных прожить можно, но без циклов-то как? Проще простого. [Встроенные методы перебора JavaScript](https://learn.javascript.ru/array-iteration) покрывают 90% рутинных нужд в циклах. Описывать как ими пользоваться я не буду, это объясняют лучше меня по ссылке выше. Я же постараюсь как можно проще описать самые используемые и привести типичные юзкейсы.

### map
Возвращает новый массив, над каждым элементом  поработала функция f(элемент_массива), которую вы передаёте в качестве первого аргумента. Типичные юзкейсы: получить из массива объектов массив из конкретного поля объектов, трансформировать каждое значение из массива.

### filter и sort
Названия говорят сами за себя: первый метод фильтрует, второй сортирует.

### reduce
А вот эта интереснее. На пальцах описать сложно, грубо говоря применяет функцию на каждый элемент массива с сохранением прошлого результата, возвращает его же. Используется когда надо сократить массив до одного значения, например найти сумму всех элементов массива или вернуть строку с перечислением элементов массива. Самый мощный из встроенных методов, но самый сложный для восприятия. Для полного понимания советую вывести какой-нибудь массив с помощью него и посмотреть, какое значение будет в каждом аргументе на каждой итерации, также не стоит забывать про аргумент initialValue.

### forEach
Единственный метод из перечисленных, который ничего не возвращает. Классически его используют для замены цикла for, когда без побочных эффектов не обойтись. Например, для каждого из элементов массива отправить запрос на сервер.

## Практика

Попробуем отрефакторить какой-нибудь реальный пример с минимальным изменением в логике. Для чистоты эксперимента я залез на сайт с компонентами Vue и взял первый попавшийся на глаза репозиторий. Это компонент для Vue, который генерирует программную анимацию текста из случайных букв и цифр. Основной движ компонента происходит в следующих строчках:
```javascript
 this.textRendered = "";
                //create initial garble string
                for (var i = 0; i < this.text.length; i++) {
                    if (this.text.charAt(i) != " ") {
                        this.textRendered += Math.random().toString(36).substr(2, 1);
                    } else {
                        this.textRendered += " ";
                    }
                }
                this.garbleInterval = setInterval(() => {
                    //by chance add either real char or another random
                    for (var i = 0; i < this.text.length; i++) {
                        if (this.text.charAt(i) != " " && this.text.charAt(i) != this
                            .textRendered.charAt(i)) {
                            if (Math.random() > this.chance) {
                                //another random
                                this.textRendered = this.replaceAt(this.textRendered, i, Math
                                    .random().toString(36).substr(2, 1));
                            } else {
                                //the real one
                                this.textRendered = this.replaceAt(this.textRendered, i, this
                                    .text.charAt(i));
                            }
                        }
                    }
```
Ухх. Для начала попробуем переписать 1 цикл. Всё что он делает, это просто проходит по символам в строке и меняет их на случайное значение. В отдельности выглядит несложно, но требует времени, чтобы понять что тут происходит и внимания, чтобы запомнить все изменяющиеся переменные. Для начала избавимся от цикла, он здесь явно лишний:
```js
this.textRendered = this.text.split('').map(v => v !== ' ' ? Math.random().toString(36).substr(2, 1)) : " ").join('');
```
Без цикла выглядит компактнее, но неказистость и сумбурность в коде никуда не ушла, спасибо реализации рандомайзера. Вынесем её в отдельную функцию, тем более дальше по коду она нам ещё пригодится.
```js
const getRandomChar = () => Math.random().toString(36).substr(2, 1);
this.textRendered = this.text.split('').map(v => v !== ' ' ? getRandomChar() : " ").join('');
```
Можно ли назвать этот код чисто функциональным? Абсолютно нет. Можно ли продолжить улучшать его? Разумеется. Но наша цель на данный момент улучшить качество при минимальных усилиях, а как известно 20% усилий приносят 80% результата.

Следующий кусок кода более трудоёмкий, в нём нас ожидают классические грехи императивного подхода: циклы с условием, вложеность, дублирование кода. Для начала попробуем понять, что делают отдельные куски кода в условиях и вынести их в правильно именованные функции:
```js
this.text.charAt(i) != " " && this.text.charAt(i) != this.textRendered.charAt(i)
```
Проверяет должен ли меняться текущий символ или нет. Так и назовём:
```js
const shouldBeCharReplaced = (i) => this.text.charAt(i) != " " && this.text.charAt(i) != this.textRendered.charAt(i);
```
Хочу заметить, что мы используем внешние переменные в нашей функции, что не есть хорошо, но наша цель на сегодня не написать идеальный функциональный код, а сделать уже существующий код более читаемым с минимальными усилиями. Конечно же, в идеале мы бы хотели полностью переписать логику компонента, но предположим на нас давят сроки, а компонент нужен читаемым прямо сейчас.
Но что-то я отвлёкся. Далее:
```js
if (Math.random() > this.chance) {
                                //another random
                                this.textRendered = this.replaceAt(this.textRendered, i, Math
                                    .random().toString(36).substr(2, 1));
                            } else {
                                //the real one
                                this.textRendered = this.replaceAt(this.textRendered, i, this
                                    .text.charAt(i));
                            }
```
Меняет символ на текущем индексе на еще один рандом или настоящий в зависимости от коэфициента. Проще простого, к тому же вишенкой на торте мы видим код, который мы уже вынесли в отдельную функцию getRandomChar():
```js
const stringWithReplacedChar = (i) => {
    if(Math.random() > this.chance) {
        return this.replaceAt(this.textRendered, i, getRandomChar())
        }
        return replaceAt(this.textRendered, i, this.text.charAt(i));
}
```
Осталось избавиться от цикла и соединить всё вместе. Т.к. в реализации автор внутри цикла каждый раз меняет всю строку, а изначальную реализацию мы решили не трогать из-за якобы горящих сроков, то придётся использовать forEach, который чаще всего используется для обработки побочных эффектов.
```js
// _ используем как плейсхолдер для ненужного нам значения
text.split('').forEach((_,i) => {
    if(shouldBeCharReplaced(i)) {
        textRendered = stringWithReplacedChar(i);
    }
}) 
```

Полный результат рефакторинга:
```js
const getRandomChar = () => Math.random().toString(36).substr(2, 1);

const shouldBeCharReplaced = (i) => this.text.charAt(i) != " " && this.text.charAt(i) != this.textRendered.charAt(i);

//by chance add either real char or another random
const stringWithReplacedChar = (i) => {
    if(Math.random() > this.chance) {
        //another random
        return this.replaceAt(this.textRendered, i, getRandomChar());
        }
        //the real one
        return replaceAt(this.textRendered, i, this.text.charAt(i));
}

//create initial garble string
this.textRendered = this.text.split('').map(v => v !== ' ' ? getRandomChar() : " ").join('');

text.split('').forEach((_,i) => {
    if(shouldBeCharReplaced(i)) {
        this.textRendered = stringWithReplacedChar(i);
    }
}) 

```
В итоге теперь, чтобы понять, как работает компонент, нам необходимо посмотреть лишь на последние 6 строк вместо первоначальных циклов и вложенных условий. Конечно, будь у нас больше времени, мы бы могли в разы улучшить и данный пример. Например использовать композицию, сделать переменные максимально неизменяемыми, полностью избавиться от условий и побочных эффектов, но это уже тема для другой статьи (:
